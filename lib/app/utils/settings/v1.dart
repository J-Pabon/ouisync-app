import 'dart:io' show Directory, Platform;
import 'dart:convert';
import 'dart:collection';

import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart' as path_provider;
import 'package:shared_preferences/shared_preferences.dart';

import '../../models/models.dart';
import '../utils.dart';
import '../master_key.dart';
import 'v0/v0.dart' as v0;

class DatabaseId {
  final String _id;
  DatabaseId(String databaseId) : _id = databaseId;

  @override
  String toString() => _id;
}

//--------------------------------------------------------------------

sealed class AuthMode {
  Map _toJson();

  // May throw.
  static AuthMode fromJson(dynamic data) {
    var decoded = _AuthModeBlindOrManual._fromJson(data);
    if (decoded != null) return decoded;
    decoded = _AuthModePasswordStoredOnDevice._fromJson(data);
    if (decoded == null) throw FailedToParseAuthMode();
    return decoded;
  }
}

class _AuthModeBlindOrManual extends AuthMode {
  static String _tag() => "password-provided-by-user";

  @override
  Map _toJson() => {
        _tag(): null,
      };

  static AuthMode? _fromJson(dynamic data) {
    if (data.containsKey(_tag())) {
      return _AuthModeBlindOrManual();
    } else {
      return null;
    }
  }
}

// Note: It's normally not a good idea to store encrypted passwords on the
// device because if they are low entropy, then they could be easily brute
// forced. However, currently we only store passwords if they are generated by
// our password generating function which does have big entropy.
// TODO: It's till not ideal to do it this way because this stored password will
// go through a slow key derivation function in the ouisync library.
class _AuthModePasswordStoredOnDevice extends AuthMode {
  final String encryptedPassword;
  final bool confirmWithBiometrics;

  _AuthModePasswordStoredOnDevice(
      this.encryptedPassword, this.confirmWithBiometrics);

  // May throw.
  LocalPassword getRepositoryPassword(MasterKey masterKey) {
    final decrypted = masterKey.decrypt(encryptedPassword);
    if (decrypted == null) throw FailedToDecryptError();
    return LocalPassword(decrypted);
  }

  static String _tag() => "password-stored-on-device";

  @override
  Map _toJson() => {
        _tag(): {
          "encryptedPassword": encryptedPassword,
          "confirmWithBiometrics": confirmWithBiometrics,
        }
      };

  static AuthMode? _fromJson(dynamic data) {
    final values = data[_tag()];
    if (values == null) return null;
    String? encryptedPassword = values["encryptedPassword"];
    if (encryptedPassword == null) return null;
    bool? confirmWithBiometrics = values["confirmWithBiometrics"];
    if (confirmWithBiometrics == null) return null;
    return _AuthModePasswordStoredOnDevice(
        encryptedPassword, confirmWithBiometrics);
  }
}

//--------------------------------------------------------------------

class SettingsRepoEntry {
  AuthMode authMode;
  RepoLocation location;

  String get name => location.name;
  Directory get dir => location.dir;

  SettingsRepoEntry(this.authMode, this.location);

  Map toJson() {
    return {
      'authMode': authMode._toJson(),
      'location': location.path(),
    };
  }

  // May throw.
  factory SettingsRepoEntry.fromJson(dynamic data) {
    final authMode = data['authMode'];
    final location = data['location'];
    if (authMode == null || location == null) {
      throw FailedToParseSettingsRepoEntry();
    }
    return SettingsRepoEntry(
      AuthMode.fromJson(authMode),
      RepoLocation.fromDbPath(location),
    );
  }
}

//--------------------------------------------------------------------

class RepoSettings {
  final Settings _settings;
  final DatabaseId _databaseId;
  final SettingsRepoEntry _entry;

  RepoSettings(this._settings, this._databaseId, this._entry);

  RepoLocation get location => _entry.location;
  DatabaseId get databaseId => _databaseId;
  String get name => _entry.name;
  Directory get dir => _entry.dir;

  Future<void> setAuthModePasswordProvidedByUser() async {
    _entry.authMode = _AuthModeBlindOrManual();
    await _settings._storeRoot();
  }

  Future<void> setAuthModePasswordStoredOnDevice(
      LocalPassword password, bool requireAuthentication) async {
    // We currently use a random generator to generate passwords of length 24
    // and we only store those.  This assertion here is just a reminder that we
    // must not use this function for user provided passwords.
    assert(password.length >= 24);

    final encryptedPwd = _settings._masterKey.encrypt(password.string);

    _entry.authMode =
        _AuthModePasswordStoredOnDevice(encryptedPwd, requireAuthentication);

    await _settings._storeRoot();
  }

  bool hasLocalSecret() {
    return _entry.authMode is _AuthModePasswordStoredOnDevice;
  }

  bool shouldCheckBiometricsBeforeUnlock() {
    final authMode = _entry.authMode;
    return (authMode is _AuthModePasswordStoredOnDevice) &&
        authMode.confirmWithBiometrics;
  }

  /// May throw if the function failed to decrypt the stored key.
  /// Returns null if the authMode is _AuthModeBlindOrManual.
  LocalSecret? getLocalSecret() {
    final authMode = _entry.authMode;
    switch (authMode) {
      case _AuthModeBlindOrManual():
        return null;
      case _AuthModePasswordStoredOnDevice():
        final pwd = _settings._masterKey.decrypt(authMode.encryptedPassword);
        if (pwd == null) throw FailedToDecryptError();
        return LocalPassword(pwd);
    }
  }

  PasswordMode get passwordMode => !hasLocalSecret()
      ? PasswordMode.manual
      : shouldCheckBiometricsBeforeUnlock()
          ? PasswordMode.bio
          : PasswordMode.none;
}

//--------------------------------------------------------------------

class SettingsRoot {
  static const int version = 1;

  // Did the user accept the eQ values?
  bool acceptedEqualitieValues = false;
  // Show onboarding (will flip to false once shown).
  bool showOnboarding = true;
  bool launchAtStartup = true;
  bool enableSyncOnMobileInternet = true;
  int? highestSeenProtocolNumber;
  // TODO: In order to preserve plausible deniability, make sure that when a
  // current repo is locked, that this value is set to `null`.
  DatabaseId? currentRepo;
  Map<DatabaseId, SettingsRepoEntry> repos = {};

  SettingsRoot._();

  SettingsRoot({
    required this.acceptedEqualitieValues,
    required this.showOnboarding,
    required this.launchAtStartup,
    required this.enableSyncOnMobileInternet,
    required this.highestSeenProtocolNumber,
    required this.currentRepo,
    required this.repos,
  });

  Map<String, dynamic> toJson() {
    final r = {
      'version': version,
      'acceptedEqualitieValues': acceptedEqualitieValues,
      'showOnboarding': showOnboarding,
      'launchAtStartup': launchAtStartup,
      'enableSyncOnMobileInternet': enableSyncOnMobileInternet,
      'highestSeenProtocolNumber': highestSeenProtocolNumber,
      'currentRepo': currentRepo?.toString(),
      'repos': <String, dynamic>{
        for (var kv in repos.entries) kv.key.toString(): kv.value.toJson()
      },
    };
    return r;
  }

  factory SettingsRoot.fromJson(String? s) {
    if (s == null) {
      return SettingsRoot._();
    }

    final data = json.decode(s);

    int inputVersion = data['version'];

    if (inputVersion != version) {
      throw "Invalid settings version ($inputVersion)";
    }

    final repos = <DatabaseId, SettingsRepoEntry>{
      for (var kv in data['repos']!.entries)
        DatabaseId(kv.key): SettingsRepoEntry.fromJson(kv.value)
    };

    String? currentRepo = data['currentRepo'];

    return SettingsRoot(
      acceptedEqualitieValues: data['acceptedEqualitieValues']!,
      showOnboarding: data['showOnboarding']!,
      launchAtStartup: data['launchAtStartup']!,
      enableSyncOnMobileInternet: data['enableSyncOnMobileInternet']!,
      highestSeenProtocolNumber: data['highestSeenProtocolNumber'],
      currentRepo: currentRepo != null ? DatabaseId(currentRepo) : null,
      repos: repos,
    );
  }
}

class Settings with AppLogger {
  static const String settingsKey = "settings";

  final SettingsRoot _root;
  final SharedPreferences _prefs;
  final MasterKey _masterKey;

  //------------------------------------------------------------------

  Settings._(this._root, this._prefs, this._masterKey);

  Future<void> _storeRoot() async {
    await _prefs.setString(settingsKey, json.encode(_root.toJson()));
  }

  static Future<Settings> init(
      SharedPreferences prefs, MasterKey masterKey) async {
    final json = prefs.getString(settingsKey);
    final root = SettingsRoot.fromJson(json);

    if (prefs.getKeys().length > 1) {
      // The previous migration did not finish correctly, prefs should only
      // `settingsKey` key after success.
      await Settings._removeValuesFromV0(prefs);
    }

    return Settings._(root, prefs, masterKey);
  }

  static Future<Settings> initMigrateFromV0(
      SharedPreferences prefs, MasterKey masterKey) async {
    final s0 = await v0.Settings.init(prefs);
    final eqValues = s0.getEqualitieValues();
    final showOnboarding = s0.getShowOnboarding();
    final launchAtStartup = s0.getLaunchAtStartup();
    final enableSyncOnMobileInternet = s0.getSyncOnMobileEnabled();
    final highestSeenProtocolNumber = s0.getHighestSeenProtocolNumber();
    final currentRepo = s0.getDefaultRepo();

    final Map<DatabaseId, SettingsRepoEntry> repos = HashMap();

    for (final repo in s0.repos()) {
      final id = DatabaseId(repo.databaseId);
      final auth = s0.getAuthenticationMode(repo.name);
      AuthMode? newAuth;
      v0.SecureStorage? oldPwdStorage;
      switch (auth) {
        case v0.AuthMode.manual:
          newAuth = _AuthModeBlindOrManual();
        case v0.AuthMode.version1:
        case v0.AuthMode.version2:
          oldPwdStorage = v0.SecureStorage(databaseId: id);
          final password = await oldPwdStorage.tryGetPassword(
              authMode: v0.AuthMode.noLocalPassword);
          newAuth = _AuthModePasswordStoredOnDevice(password!, true);
        case v0.AuthMode.noLocalPassword:
          oldPwdStorage = v0.SecureStorage(databaseId: id);
          final password = await oldPwdStorage.tryGetPassword(
              authMode: v0.AuthMode.noLocalPassword);
          newAuth = _AuthModePasswordStoredOnDevice(password!, false);
      }
      // Remove the password from the old storage.
      if (oldPwdStorage != null) {
        await oldPwdStorage.deletePassword();
      }
      repos[id] = SettingsRepoEntry(newAuth, repo.info);
    }

    final root = SettingsRoot(
      acceptedEqualitieValues: eqValues,
      showOnboarding: showOnboarding,
      launchAtStartup: launchAtStartup,
      enableSyncOnMobileInternet: enableSyncOnMobileInternet,
      highestSeenProtocolNumber: highestSeenProtocolNumber,
      currentRepo: (currentRepo != null) ? DatabaseId(currentRepo) : null,
      repos: repos,
    );

    final s1 = Settings._(root, prefs, masterKey);

    // The order of these operations is important to avoid data loss.
    await s1._storeRoot();
    await Settings._removeValuesFromV0(prefs);

    return s1;
  }

  // Remove keys that don't belong to this version of settings.  It's important
  // to do this **after** we've stored the root and version number of this
  // settings.
  static Future<void> _removeValuesFromV0(SharedPreferences prefs) async {
    for (final key in prefs.getKeys()) {
      if (key != settingsKey) {
        await prefs.remove(key);
      }
    }
  }

  //------------------------------------------------------------------

  bool getEqualitieValues() => _root.acceptedEqualitieValues;

  Future<void> setEqualitieValues(bool value) async {
    _root.acceptedEqualitieValues = value;
    await _storeRoot();
  }

  //------------------------------------------------------------------

  bool getShowOnboarding() => _root.showOnboarding;

  Future<void> setShowOnboarding(bool value) async {
    _root.showOnboarding = value;
    await _storeRoot();
  }

  //------------------------------------------------------------------

  bool getLaunchAtStartup() => _root.launchAtStartup;

  Future<void> setLaunchAtStartup(bool value) async {
    _root.launchAtStartup = value;
    await _storeRoot();
  }

  //------------------------------------------------------------------

  bool getSyncOnMobileEnabled() => _root.enableSyncOnMobileInternet;

  Future<void> setSyncOnMobileEnabled(bool enable) async {
    _root.enableSyncOnMobileInternet = enable;
    await _storeRoot();
  }

  //------------------------------------------------------------------

  int? getHighestSeenProtocolNumber() => _root.highestSeenProtocolNumber;

  Future<void> setHighestSeenProtocolNumber(int number) async {
    _root.highestSeenProtocolNumber = number;
    await _storeRoot();
  }

  //------------------------------------------------------------------

  Iterable<RepoSettings> repos() =>
      _root.repos.entries.map((kv) => RepoSettings(this, kv.key, kv.value));

  //------------------------------------------------------------------

  RepoSettings? repoSettingsByName(String name) {
    for (final kv in _root.repos.entries) {
      if (kv.value.name == name) {
        return RepoSettings(this, kv.key, kv.value);
      }
    }

    return null;
  }

  RepoSettings? repoSettingsById(DatabaseId repoId) {
    final entry = _root.repos[repoId];
    if (entry == null) return null;
    return RepoSettings(this, repoId, entry);
  }

  //------------------------------------------------------------------

  String? getDefaultRepo() {
    final current = _root.currentRepo;
    if (current == null) {
      return null;
    } else {
      return _root.repos[current]?.location.name;
    }
  }

  Future<void> setDefaultRepo(String? name) async {
    if (name == null) {
      if (_root.currentRepo == null) {
        return;
      }
      _root.currentRepo = null;
    } else {
      final rs = repoSettingsByName(name);
      if (rs == null || rs.name == name) {
        return;
      }
      // We must not set repositories for which the user provides the password
      // as "default" because they must be indistinguishable from blind
      // repositories.
      if (rs.passwordMode == PasswordMode.manual) {
        return;
      }
      _root.currentRepo = rs.databaseId;
    }

    await _storeRoot();
  }
  //------------------------------------------------------------------

  Future<void> renameRepository(
      RepoSettings repoSettings, String newName) async {
    if (repoSettings.name == newName) {
      // TODO: This should just return without throwing, but check where it's used.
      throw 'Failed to rename repo: "$newName" to same name';
    }

    if (repoSettingsByName(newName) != null) {
      throw 'Failed to rename repo: "$newName" already exists';
    }

    final oldInfo = repoSettings._entry.location;
    repoSettings._entry.location =
        RepoLocation.fromDirAndName(oldInfo.dir, newName);
    await _storeRoot();
  }

  //------------------------------------------------------------------

  Future<RepoSettings?> addRepoWithPasswordStoredOnDevice(
      RepoLocation location, LocalPassword password, DatabaseId databaseId,
      {required requireBiometricCheck}) async {
    final authMode = _AuthModePasswordStoredOnDevice(
        _masterKey.encrypt(password.string), requireBiometricCheck);
    return await _addRepo(location, databaseId: databaseId, authMode: authMode);
  }

  Future<RepoSettings?> addRepoWithUserProvidedPassword(
    RepoLocation location,
    DatabaseId databaseId,
  ) async {
    final authMode = _AuthModeBlindOrManual();
    return await _addRepo(location, databaseId: databaseId, authMode: authMode);
  }

  Future<RepoSettings?> _addRepo(
    RepoLocation location, {
    required DatabaseId databaseId,
    required AuthMode authMode,
  }) async {
    if (_root.repos.containsKey(databaseId)) {
      loggy.debug('Settings already contains a repo with the id "$databaseId"');
      return null;
    }

    if (repoSettingsByName(location.name) != null) {
      loggy.debug(
          'Settings already contains a repo with the name "${location.name}"');
      return null;
    }

    final entry = SettingsRepoEntry(authMode, location);
    _root.repos[databaseId] = entry;

    await _storeRoot();

    return RepoSettings(this, databaseId, entry);
  }

  //------------------------------------------------------------------

  Future<void> forgetRepository(DatabaseId databaseId) async {
    if (_root.currentRepo == databaseId) {
      _root.currentRepo = null;
    }
    _root.repos.remove(databaseId);
    await _storeRoot();
  }

  //------------------------------------------------------------------

  Future<Directory> defaultRepoLocation() async {
    // TODO
    try {
      // Docs says this throws on non Android systems.
      // https://pub.dev/documentation/path_provider/latest/path_provider/getExternalStorageDirectory.html
      //
      // On Android this function will most likely return the user accessible
      // directory on phone's internal memory (i.e. not the SDCard). The user
      // will see it as "<DEVICE>/Phone/Android/data/org.equalitie.ouisync/files"
      //
      // Everything in this folder is deleted when the app is un/re-installed.
      final dir = await path_provider.getExternalStorageDirectory();
      if (dir != null) {
        return dir;
      }
    } catch (_) {}

    // This path is not accessible by the user using a file explorer and it
    // also gets deleted when the app is un/re-installed.
    final alternativeDir =
        await path_provider.getApplicationDocumentsDirectory();

    if (Platform.isAndroid) {
      return alternativeDir;
    }

    final context = p.Context(style: p.Style.posix);

    final nonAndroidAlternativePath =
        context.join(alternativeDir.path, 'ouisync');

    return await Directory(nonAndroidAlternativePath).create();
  }

  //------------------------------------------------------------------

  String? getMountPoint() => _defaultMountPoint();
}

String? _defaultMountPoint() {
  if (Platform.isLinux || Platform.isMacOS) {
    final home = Platform.environment['HOME'];

    if (home == null) {
      return null;
    }

    return '$home/Ouisync';
  } else if (Platform.isWindows) {
    return 'O:';
  } else {
    return null;
  }
}

sealed class SettingsError {}

class FailedToDecryptError extends SettingsError {}

class FailedToParseAuthMode extends SettingsError {}

class FailedToParseSettingsRepoEntry extends SettingsError {}
