import 'package:biometric_storage/biometric_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:local_auth/local_auth.dart';
import 'package:random_password_generator/random_password_generator.dart';

import '../../../generated/l10n.dart';
import '../../cubits/cubits.dart';
import '../../models/models.dart';
import '../../utils/loggers/ouisync_app_logger.dart';
import '../../utils/utils.dart';
import '../widgets.dart';

class RepositoryCreation extends StatefulWidget {
  RepositoryCreation({Key? key, required this.context, required this.cubit})
      : super(key: key);

  final BuildContext context;
  final ReposCubit cubit;

  @override
  State<RepositoryCreation> createState() => _RepositoryCreationState();
}

class _RepositoryCreationState extends State<RepositoryCreation>
    with OuiSyncAppLogger {
  final _repositoryNameInputKey = GlobalKey<FormFieldState>();
  final _passwordInputKey = GlobalKey<FormFieldState>();
  final _retypePasswordInputKey = GlobalKey<FormFieldState>();

  final TextEditingController _nameController =
      TextEditingController(text: null);

  final TextEditingController _passwordController =
      TextEditingController(text: null);

  final TextEditingController _retypedPasswordController =
      TextEditingController(text: null);

  final _repoNameFocus = FocusNode();
  final _passwordFocus = FocusNode();

  bool _obscurePassword = true;
  bool _obscurePasswordConfirm = true;

  bool _biometricsAvailable = false;
  bool _useBiometrics = false;

  bool _generatePassword = true;

  bool _showPasswordInput = false;
  bool _showRetypePasswordInput = false;

  @override
  void initState() {
    super.initState();

    isBiometricsAvailable().then((isAvailable) {
      setState(() {
        _biometricsAvailable = isAvailable ?? false;
        _useBiometrics = isAvailable ?? false;
      });

      _configureInputs(_generatePassword, _useBiometrics);

      if (isAvailable == null) return; //Device without biometrics

      if (isAvailable == false) {
        // Show dialog asking the user to enable biometrics
        return;
      }
    });

    _repoNameFocus.requestFocus();
  }

  Future<bool?> isBiometricsAvailable() async {
    final auth = LocalAuthentication();

    final isBiometricsAvaiable = await auth.canCheckBiometrics;
    if (!isBiometricsAvaiable) {
      return null; //The device doesn't have biometrics
    }

    final availableBiometrics = await auth.getAvailableBiometrics();
    if (availableBiometrics.isEmpty) {
      return false; //The device has biometrics, but the user hasn't configured them
    }

    return true;
  }

  String _generateRandomPassword() {
    final password = RandomPasswordGenerator();
    final autogeneratedPassword = password.randomPassword(
        letters: true,
        numbers: true,
        specialChar: true,
        uppercase: true,
        passwordLength: 24);

    if (kDebugMode) {
      loggy.app(
          'Autogenerated password for repo ${_nameController.text}: $autogeneratedPassword');
    }

    return autogeneratedPassword;
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      child: Column(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            SingleChildScrollView(
                reverse: true,
                child: _buildCreateRepositoryWidget(widget.context))
          ]),
    );
  }

  Widget _buildCreateRepositoryWidget(BuildContext context) {
    return Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Dimensions.spacingVerticalDouble,
          _repoName(),
          _passwordInputs(),
          _generatePasswordCheckbox(),
          if (_biometricsAvailable) _useBiometricsCheckbox(),
          _manualPasswordWarning(),
          Fields.dialogActions(context, buttons: _actions(context)),
        ]);
  }

  Widget _repoName() {
    return Fields.formTextField(
        key: _repositoryNameInputKey,
        context: context,
        textEditingController: _nameController,
        label: S.current.labelName,
        hint: S.current.messageRepositoryName,
        onSaved: (_) {},
        validator:
            validateNoEmpty(S.current.messageErrorFormValidatorNameDefault),
        autovalidateMode: AutovalidateMode.disabled,
        focusNode: _repoNameFocus);
  }

  Widget _passwordInputs() => Container(
          child: Column(
        children: [
          Visibility(
              visible: _showPasswordInput,
              child: Row(children: [
                Expanded(
                    child: Fields.formTextField(
                        key: _passwordInputKey,
                        context: context,
                        textEditingController: _passwordController,
                        obscureText: _obscurePassword,
                        label: S.current.labelPassword,
                        subffixIcon: Fields.actionIcon(
                            Icon(
                              _obscurePassword
                                  ? Constants.iconVisibilityOn
                                  : Constants.iconVisibilityOff,
                              size: Dimensions.sizeIconSmall,
                            ), onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        }),
                        hint: S.current.messageRepositoryPassword,
                        onSaved: (_) {},
                        validator: validateNoEmpty(
                            Strings.messageErrorRepositoryPasswordValidation),
                        autovalidateMode: AutovalidateMode.disabled,
                        focusNode: _passwordFocus))
              ])),
          Visibility(
              visible: _showRetypePasswordInput,
              child: Row(children: [
                Expanded(
                  child: Fields.formTextField(
                      key: _retypePasswordInputKey,
                      context: context,
                      textEditingController: _retypedPasswordController,
                      obscureText: _obscurePasswordConfirm,
                      label: S.current.labelRetypePassword,
                      subffixIcon: Fields.actionIcon(
                          Icon(
                            _obscurePasswordConfirm
                                ? Constants.iconVisibilityOn
                                : Constants.iconVisibilityOff,
                            size: Dimensions.sizeIconSmall,
                          ), onPressed: () {
                        setState(() =>
                            _obscurePasswordConfirm = !_obscurePasswordConfirm);
                      }),
                      hint: S.current.messageRepositoryPassword,
                      onSaved: (_) {},
                      validator: (retypedPassword) => retypedPasswordValidator(
                            password: _passwordController.text,
                            retypedPassword: retypedPassword,
                          ),
                      autovalidateMode: AutovalidateMode.disabled),
                )
              ])),
        ],
      ));

  Widget _generatePasswordCheckbox() => Container(
      child: SwitchListTile.adaptive(
          value: _generatePassword,
          title:
              Text(S.current.messageGeneratePassword, textAlign: TextAlign.end),
          onChanged: (generatePassword) {
            setState(() => _generatePassword = generatePassword);

            _configureInputs(_generatePassword, _useBiometrics);
          },
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact));

  Widget _useBiometricsCheckbox() => Container(
      child: SwitchListTile.adaptive(
          value: _useBiometrics,
          title: Text(S.current.messageSecureUsingBiometrics,
              textAlign: TextAlign.end),
          onChanged: (enableBiometrics) {
            setState(() => _useBiometrics = enableBiometrics);

            _configureInputs(_generatePassword, _useBiometrics,
                preservePassword: true);
          },
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact));

  _configureInputs(bool generatePassword, bool useBiometrics,
      {bool preservePassword = false}) {
    setState(() {
      _showPasswordInput = !(generatePassword && useBiometrics);
      _showRetypePasswordInput = !generatePassword && _showPasswordInput;

      // If for some reason the user decides to keep the autogenerated password,
      // but not to use biometrics, we make the password visible to signal the user
      // that the password need to be saved manually -just as it is stated in the
      // message explaning this, made visible at the same time.
      if (generatePassword && !useBiometrics) {
        _obscurePassword = false;
      }
    });

    if (!preservePassword) {
      // Generate password or clean controllers if manual was selected by the user
      final password = _generatePassword ? _generateRandomPassword() : '';

      _passwordController.text = password;
      _retypedPasswordController.text = password;
    }

    // Set the fos and scroll to make the focused input visible
    generatePassword
        ? _scrollToVisible(_repoNameFocus)
        : _nameController.text.isEmpty
            ? _scrollToVisible(_repoNameFocus)
            : _passwordFocus.requestFocus();
  }

  void _scrollToVisible(FocusNode focusNode) => WidgetsBinding.instance
      .addPostFrameCallback((_) => Scrollable.ensureVisible(
            focusNode.context!,
            duration: const Duration(milliseconds: 200),
            curve: Curves.easeIn,
          ));

  Widget _manualPasswordWarning() => Padding(
      padding: Dimensions.paddingVertical10,
      child: Visibility(
          visible: !_useBiometrics,
          child: Fields.autosizeText(S.current.messageRememberSavePasswordAlert,
              color: Colors.red,
              maxLines: 10,
              softWrap: true,
              textOverflow: TextOverflow.ellipsis)));

  String? retypedPasswordValidator({
    required String password,
    required String? retypedPassword,
  }) {
    if (retypedPassword == null || password != retypedPassword) {
      return S.current.messageErrorRetypePassword;
    }

    return null;
  }

  List<Widget> _actions(context) => [
        NegativeButton(
            text: S.current.actionCancel,
            onPressed: () => Navigator.of(context).pop('')),
        PositiveButton(
            text: S.current.actionCreate,
            onPressed: () {
              final name = _nameController.text;
              final password = _passwordController.text;

              _createRepo(name: name, password: password);
            })
      ];

  void _createRepo({required String name, required String password}) =>
      _onSaved(widget.cubit, name, password);

  void _onSaved(ReposCubit cubit, String name, String password) async {
    final isRepoNameOk =
        _repositoryNameInputKey.currentState?.validate() ?? false;
    final isPasswordOk = _passwordInputKey.currentState?.validate() ?? false;
    final isRetypePasswordOk =
        _retypePasswordInputKey.currentState?.validate() ?? false;

    if (!isRepoNameOk) return;
    _repositoryNameInputKey.currentState!.save();

    if (!_generatePassword) {
      if (!(isPasswordOk && isRetypePasswordOk)) return;

      _passwordInputKey.currentState!.save();
      _retypePasswordInputKey.currentState!.save();
    }

    // We add the password to the biometric storage before creating the repo.
    // The reason for this is that in case of the user canceling the biometric
    // authentication, we can just stay in the dialog, before even creating the
    // repo.
    // If instead we first create the repo, then add biometrics and there is an
    // exception  (most likely the user canceling the validation), we would
    // have the repo, but no biometrics, which would be confusiong for the user.
    if (_useBiometrics) {
      final biometricsResult = await Dialogs.executeFutureWithLoadingDialog(
          context,
          f: Biometrics.addRepositoryPassword(
              repositoryName: name, password: password));

      if (biometricsResult.exception != null) {
        loggy.app(biometricsResult.exception);

        if (biometricsResult.exception is AuthException) {
          if ((biometricsResult.exception as AuthException).code !=
              AuthExceptionCode.userCanceled) {
            showSnackBar(context,
                content: Text(S.current.messageErrorAuthenticatingBiometrics));
          }
        }

        return;
      }
    }

    final info = RepoMetaInfo.fromDirAndName(
        await cubit.settings.defaultRepoLocation(), name);

    final repoEntry = await cubit.createRepository(
      info,
      password: password,
      setCurrent: true,
    );

    if (repoEntry is ErrorRepoEntry) {
      Dialogs.simpleAlertDialog(
        context: widget.context,
        title: S.current.messsageFailedCreateRepository(name),
        message: repoEntry.error,
      );

      return;
    }

    Navigator.of(widget.context).pop(name);
  }
}
